---
title: Diagnose slow database queries
metaDescription: Improve query performance by troubleshooting your slow database with the New Relic Database UI.
redirects:
---
import apmATimesliceChartofTop5DatabaseOperations from 'images/apm_screenshot-crop_A-timeslice-chart-of-top-5-database-operations.png'

import apmTopDatabasesbyQueryTime from 'images/apm_screenshot-crop_Top-databases-by-query-time.png'

When your site experiences a disruption, your customers are left waiting while you troubleshoot a problem that's as complex as your system. Your data's reporting and you have a rough idea of what could be the problem, but where do you start? 

If your site relies on a database (and it probably does), you'll want to first check that query response time is performing as expected. Often, the performance of your site depends on how well your database handles queries sent by your customers.

With New Relic, you can use our database UI to track database performance over time, letting you pinpoint when a problem occurred so you can figure out what kind of solution you need. This tutorial explains how to troubleshoot slow queries by comparing the performance of those queries against surrounding transactions. 

## Diagnose the slow query [#diagnose]

Our database UI displays charts built with NRQL queries, creating timeslice data from the `apm.service.datastore.operation.duration` metric. A typical database UI might include charts that organize your top databases by query time, throughput, and time consumed. 

When you're scoping out a problem, these charts provide different entry points into your database performance. Let's walk through how you might identify and diagnose a performance issue with your database. 

<Steps>
<Step>

<SideBySide>
  <Side>

    ```sql
    SELECT sum(apm.service.datastore.operation.duration * 1000) FROM Metric WHERE (entity.guid = YOUR_ENTITY_GUID) FACET `datastoreType`, `table`, `operation` LIMIT 5 SINCE 1800 seconds AGO TIMESERIES```

  </Side>

  <Side>
<img
  title="Top 5 Database operations over time"
  alt=""
  src={apmATimesliceChartofTop5DatabaseOperations}
/>

<figcaption>
  The database UI shows you graphs of your database operations over time.
</figcaption> 

</Side>
</SideBySide>

  This NRQL query creates a chart that displays 5 database operations, then tracks the time to execute. If, on average, one database responds to requests 400 times in a given minute then suddenly drops to 150 responses per minute, you know to drill deeper into that particular database process. 
    
</Step>

<Step>

<SideBySide>
  <Side>
      ```sql
    SELECT average(apm.service.datastore.operation.duration * 1000) FROM Metric WHERE (entity.guid = YOUR_ENTITY_GUID) FACET `datastoreType`, `table`, `operation` LIMIT 5 SINCE 1800 seconds AGO TIMESERIES```
  </Side>

  <Side>
    <img
  title="Top databases by query time"
  alt=""
  src={apmTopDatabasesbyQueryTime}
/>

<figcaption>
  The database UI shows you graphs of your top databases by query time.
</figcaption>
  </Side>

</SideBySide>

  This NRQL query creates a chart that displays top databases, then averages how long queries take. For example, if, on average, your Redis EVAL database averages about 0.5sec to process a query, but query time increased by 2 seconds, then you know to dig deeper into individual queries. 

</Step>

<Step>
Take your ever so slightly moist beans and put them in your grinder. We recommend you use a modern burr grinder and avoid blade grinders.
</Step>
</Steps>

## Get the full context, improve your performance [#fix]

Knowing that the cause of your problem has to do with your database is  only half the battle. Your real first step is 

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="compare-averages"
    title="Compare query time and throughput averages to a time window"
  >
 </Collapser>
<Collapser
    className="freq-link"
    id="break-down"
    title="Scope out the transaction calling your database"
  >
    INSERT_TEXT_HERE
  </Collapser>
  <Collapser
    className="freq-link"
    id="bottlenecks"
    title="Find bottlenecks via a stack trace"
  >
    INSERT_TEXT_HERE
  </Collapser>
</CollapserGroup>

