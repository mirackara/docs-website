---
title: Diagnose slow database queries
metaDescription: Improve query performance by troubleshooting your slow database with the New Relic Database UI.
redirects:
---
import apmATimesliceChartofTop5DatabaseOperations from 'images/apm_screenshot-crop_A-timeslice-chart-of-top-5-database-operations.png'

import apmTopDatabasesbyQueryTime from 'images/apm_screenshot-crop_Top-databases-by-query-time.png'

import apmDatabaseThroughput from 'images/apm_screenshot-crop_Database-throughput.png'

import apmDiggingDeeperIntoYourDatabase from 'images/apm_screenshot-full_Digging-deeper-into-your-database.gif'

When your site experiences a disruption, your customers are left waiting while you troubleshoot a problem that's as complex as your system. Your data's reporting and you have a rough idea of what could be the problem, but where do you start? 

If your site relies on a database (and it probably does), you'll want to first check that query response time is performing as expected. Often, the performance of your site depends on how well your database handles queries sent by your customers.

With New Relic, you can use our database UI to track database performance over time, letting you pinpoint when a problem occurred so you can figure out what kind of solution you need. This tutorial explains how to troubleshoot slow queries by comparing the performance of those queries against surrounding transactions.  

## Identify slow queries with the Database UI [#diagnose]

Our database UI displays charts built with NRQL queries, creating timeslice data from the `apm.service.datastore.operation.duration` metric. These charts track the response time of your database processes, then organizes your top databases by time consumed of your operations, query time, and throughput. 

When you're scoping out a problem, we recommend you examine your system with these different entry points as they tell different parts of the same story. Let's walk through how you might use the UI to begin diagnosing performance issues. 

<Steps>
<Step>

  ### Time consumed by database operations

  The ‘Most time consuming’ chart shows the total processing time on queries by a database operation. Towards the top of your chart, you can see your busiest, most frequently called queries. If an infrequently called query trends with your busiest queries, however, it may indicate a problem that needs further scoping. 

<SideBySide>
  <Side>

    ```sql
    SELECT sum(apm.service.datastore.operation.duration * 1000) FROM Metric WHERE (entity.guid = YOUR_ENTITY_GUID) FACET `datastoreType`, `table`, `operation` LIMIT 5 SINCE 1800 seconds AGO TIMESERIES```

  </Side>

  <Side>
<img
  title="Top 5 Database operations over time"
  alt=""
  src={apmATimesliceChartofTop5DatabaseOperations}
/>

<figcaption>
  The database UI shows graphs of your database operations over time.
</figcaption> 

</Side>
</SideBySide>

  This NRQL query creates a chart that displays 5 database operations, then tracks the time to execute. If, on average, one database responds to requests 400 times in a given minute then suddenly drops to 150 responses per minute, you know to drill deeper into that particular database process. 
    
</Step>

<Step>

### Top databases by query time

<SideBySide>
  <Side>
      ```sql
    SELECT average(apm.service.datastore.operation.duration * 1000) FROM Metric WHERE (entity.guid = YOUR_ENTITY_GUID) FACET `datastoreType`, `table`, `operation` LIMIT 5 SINCE 1800 seconds AGO TIMESERIES```
  </Side>

  <Side>
    <img
  title="Top databases by query time"
  alt=""
  src={apmTopDatabasesbyQueryTime}
/>

<figcaption>
  The database UI shows you graphs of your top databases by query time.
</figcaption>
  </Side>

</SideBySide>

  This NRQL query creates a chart that displays top databases, then averages how long queries take. For example, if, on average, your Redis EVAL database averages about a half-second to process a query, but query time increased by 2 seconds, then you know to dig deeper into individual queries. 

</Step>

<Step>

### Top databases by throughput

<SideBySide>
  <Side>
```sql
SELECT rate(count(apm.service.datastore.operation.duration), 1 minute) FROM Metric WHERE (entity.guid = YOUR_ENTITY_GUID) LIMIT 5 SINCE 1800 seconds AGO TIMESERIES  facet concat(datastoreType, ' ', table, ' ', operation)```  
</Side>
  <Side>
    <img
  title="Top 5 Database operations over time"
  alt=""
  src={apmDatabaseThroughput}
/>

<figcaption>
  The database UI shows you graphs of your top databases by throughput.
</figcaption>
  </Side>
</SideBySide>

The throughput graphs tracks the number of processes an operation executes in a given time range. If your throughput tanks, you know to dig deeper into a particular operation. 

</Step>
</Steps>

## Digging deeper into your database queries [#fix]

Identifying the approximate area where a problem's been exposed is only part of the resolution. After looking at how your database performs on average, your next step is to dig deeper into the operation. Below are three paths we recommend for digging deeper into the status of your database.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="compare-averages"
    title="Compare query time and throughput averages to a time window"
  >
  <img
  title="Database UI operations view"
  alt=""
  src={apmDiggingDeeperIntoYourDatabase}
/>

From the default database UI view, click on your most active database operation. This exchanges the default view—the three charts that show average performance of your operations, query time, and throughput—with a separate view specific to your selected operation. 


 </Collapser>
<Collapser
    className="freq-link"
    id="break-down"
    title="Scope out the transaction calling your database"
  >
    INSERT_TEXT_HERE
  </Collapser>
  <Collapser
    className="freq-link"
    id="bottlenecks"
    title="Find bottlenecks via a stack trace"
  >
    INSERT_TEXT_HERE
  </Collapser>
</CollapserGroup>

