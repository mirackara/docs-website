---
title: 'OpenTelemetry tutorials: Instrument a sample Python app'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: To test out OpenTelemetry on a sample Pythyon app instead of your own app, consider these three tutorials.
---

import openttelemetryPythonIntroImage from 'images/opentelemetry_screenshot-crop_python-intro.png'

import opentelemetryPythonFindTraceGroup from 'images/opentelemetry_screenshot-crop_find-trace-group.png'

import opentelemetryPythonDistributedTracingError from 'images/opentelemetry_screenshot-crop_python-distributed-tracing-error.png'

import opentelemetryPythonInProcessSpans from 'images/opentelemetry_screenshot-crop_python-in-process-spans.png'

import opentelemetryPythonExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_python-exception-on-span-event.png'

import opentelemetryPytyhonAttributesTab from 'images/opentelemetry_screenshot-crop_python-attributes-tab.png'

import opentelemetryPythonMetricsExplorerMain from 'images/opentelemetry_screenshot-crop_python-metrics-explorer-main.png'

import opentelemetryPythonMetricsExplorerDimensions from 'images/opentelemetry_screenshot-crop_python-metrics-explorer-dimensions.png'

import opentelemetryPythonMainLogsPage from 'images/opentelemetry_screenshot-full_python-main-logs-page.png'

import opentelemetryPythonLogsinTerminal from 'images/opentelemetry_screenshot-full_python-logs-in-terminal.png'

import opentelemetryPythonLogDetailsWithTrace from 'images/opentelemetry_screenshot-full_python-log-details-with-trace.png'

import opentelemetryPythonTraceRelatedtoLog from 'images/opentelemetry_screenshot-full_python-trace-related-to-log.png'

import opentelemetryPythonTraceWaterfallFromLog from 'images/opentelemetry_screenshot-full_python-trace-waterfall-from-log.png'

import opentelemetryPythonLogCapturedinTraceSpan from 'images/opentelemetry_screenshot-full_python-log-captured-in-trace-span.png'





<SideBySide>
  <Side>
    Try out these three Python tutorials to see what the New Relic platform can do with your OTLP data. We have three tutorials you can choose from, each one using the same demo Flask app. The app will calculate the nth number in the Fibonacci sequence and generate traces, metrics, and logs.

    By working through these tutorials, you can learn skills to help you set up your own app with OpenTelemetry and New Relic.

  </Side>
  <Side>
    <img
      title="Screenshot showing response time, throughput, and error rate"
      alt="Screenshot showing response time, throughput, and error rate"
      src={openttelemetryPythonIntroImage}
    />

    <figcaption>
      After you finish any of these tutorials, you can view span metrics in charts like these.
    </figcaption>
  </Side>
</SideBySide>

While each tutorial uses the same demo app, they have different approaches to help you become acquainted with OpenTelemetry and New Relic. Try out the options that are interesting to you:

    * [Tutorial 1: Run the pre-instrumented demo app:](#pre-instrum) This is the fastest way to send some demo data to New Relic and see how it is displayed in the UI. In this tutorial, the demo app has pre-loaded instrumentation and SDK configurations that follow our [best practices](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-overview/) to generate and export metrics, logs, and traces. You can inspect our code and apply relevant sections to your own apps.
    * [Tutorial 2: Monitor the demo app with the OpenTelemetry Python agent:](#python-agent) Instead of using our pre-instrumented demo app, you can use the OpenTelemetry Python agent to automatically monitor our demo app. You don't need to open the demo code and make any changes&mdash;just install and run the agent alongside the app.
    * [Tutorial 3: Set up the demo app manually:](#manual-instrum) In this track, you'll roll up your sleeves and tinker with the engine of the car. This is the approach to take if you want to have the most control over what telemetry is reported and want to see details about how it's done. You'll manually insert instrumentation into our demo app to capture telemetry and you'll configure the SDK to export that data to New Relic.

<Callout variant="tip">
You have two choices for exporting data from your application to New Relic via OTLP:
* Directly from your app
* Via an OpenTelemetry collector

This guide covers the first option. If you wish to export your data via a collector, check out this [collector documentation](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/collector/opentelemetry-collector-basic/) for details.
</Callout>
## Requirements [#requirements]

Before you get started, make sure you have the following:

* A New Relic account: Sign up for a [free account](https://newrelic.com/signup) if you don't already have one.
* Python 3.8 or higher, and pip (included in Python version 3.4 and later): If you don't already have these, see these [download options](https://www.python.org/downloads/).

## Tutorial 1: Run the pre-instrumented demo app [#pre-instrum]

This is a great option if you want us to do the instrumentation so you can quickly see what's it's like to send data to New Relic and view it in our UI.

1. In your terminal, run the following to clone the demo app and navigate to the Getting Started Guides' `python/instrumented` directory.
    ```
    git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
    cd newrelic-opentelemetry-examples/getting-started-guides/python/instrumented
    ```
2. Set these environment variables to send data to your New Relic account:
    * Make sure to use your <InlinePopover type="licenseKey" />.
    * If your New Relic data center region is EU and not US, set the endpoint to: `https://otlp.eu01.nr-data.net:4317`

      * OTEL_EXPORTER_OTLP_HEADERS=api-key=INSERT_YOUR_NEW_RELIC_LICENSE_KEY
      * OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317
3. Set this environment variable to name the service; this is how you will identify your service in your New Relic account: 
      * OTEL_SERVICE_NAME=getting-started-python 
3. In the same `getting-started-guides/python/instrumented/` directory, create and activate a virtual environment, install the required libraries, and run the app:
      * macOS:
        ```
        python3 -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
        python app.py
        ```
        
      * PowerShell:
        ```
        python -m venv venv
        .\venv\Scripts\Activate.ps1
        pip install -r requirements.txt
        python3 app.py
        ```
4. Open a new terminal tab, switch to the `getting-started-guides/python/instrumented` directory, and run the following command to generate some traffic to the application:
    * macOS:
      ```
      ./load-generator.sh
      ```
    * PowerShell:
      ```
      .\load-generator.ps1
      ```

    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with a value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>
5. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
6. Click your new entity (service) called `getting-started-python` and explore the UI. For more tips about what to look for in the UI, see [View your data in New Relic](#view-data).
7. When you're finished looking at your data in the UI, shut down the application by pressing `CONTROL+C` in both terminal sessions.

## Tutorial 2: Monitor the demo app with the OpenTelemetry Python agent [#python-agent]

Here's a different tutorial that also uses the same demo app, but in this case, you'll use the OpenTelemetry Python agent to automatically monitor the demo app. You don't need to modify the Python source code. By using the agent, you can quickly start exporting sample data to New Relic. 

Note, however, that you will need to add custom instrumentation to capture deeper levels of information about the app, such as logs and custom metrics. 

The auto-instrumentation agent is a series PyPI package that dynamically injects bytecode to capture telemetry from popular libraries and frameworks. You can also use it to capture data such as inbound requests, outbound HTTP calls, and database calls. It can be attached to any Python 3 application.

<Callout variant="tip">
  See the [official OpenTelemetry Python agent documentation](https://opentelemetry.io/docs/instrumentation/python/automatic/) for additional configuration options.
</Callout>

To monitor our demo app with the OpenTelemetry Python agent:

1. Execute these two commands to download the demo application repository and change to the following directory:
    ```
    git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
    cd newrelic-opentelemetry-examples/getting-started-guides/python/uninstrumented
    ```
2. Go to our [environment variables reference section](#ref-env-vars) below to see which variables you need to export and then return to these steps. 
3. Then, in the same `getting-started-guides/python/uninstrumented/` directory, create and activate a virtual environment:
      * macOS:
        ```
        python3 -m venv venv
        source venv/bin/activate
        ```
        
      * PowerShell:
        ```
        python -m venv venv
        .\venv\Scripts\Activate.ps1
        ```
4. You are now ready to install the required libraries. The OpenTelemetry Python auto-instrumentation agent has already been included in the `requirements.txt` file, so you can run the following command to install it along with the existing libraries for the app:
      * macOS and PowerShell:
        ```
        pip install -r requirements.txt
        ```
    <Callout variant="tip">
      Instead of installing PyPI packages from the `requirements.txt` file, you can do this manually:
      ```
      pip install flask
      pip install opentelemetry-instrumentation-flask
      pip install opentelemetry-exporter-otlp
      pip install opentelemetry-distro
      ```
    </Callout> 
5. Continue in `getting-started-guides/python/uninstrumented/` to launch the agent with the app:
    * macOS:
      ```
      opentelemetry-instrument python3 app.py
      ```
    * PowerShell:
      ```
      opentelemetry-instrument python app.py
      ```
    <Callout variant="important">
      If you're using a virtual environment, remember to run the appropriate script for your operating system (for example, `.\scripts\bin\Activate.ps1`)
    </Callout>
6. Generate traffic to the application by opening a new terminal in the `getting-started-guides/python/Uninstrumented` directory and running the load generator:
    * macOS:
      ```
      ./load-generator.sh
      ```
    * PowerShell:
      ```
      .\load-generator.ps1
      ```
    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with a value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>
7. Now that you've sent some data to New Relic, see our [instructions on viewing the data in the UI](#view-data).
8. When you're finished looking at your data in the UI, shut down the application by pressing `CONTROL+C` in both terminal sessions.


## Tutorial 3: Set up the demo app manually [#manual-instrum]

The previous section helped you explore automatic instrumentation with the OpenTelemetry Python agent. If you prefer to have more control over the telemetry you gather, you can try out this tutorial to learn how to add custom instrumentation. Then, you'll see how to configure the OpenTelemetry SDK to export the data to New Relic, using our recommended best practices.

Here are the steps you'll complete for this manual setup:

* [A. Download the demo application](#download)
* [B. Install required libraries](#libraries)
* [C. Configure the SDK](#config-sdk)
* [D. Add instrumentation libraries: traces](#library-traces)
* [E. Add instrumentation libraries: metrics](#library-metrics)
* [F. Add instrumentation libraries: logs](#library-logs)
* [G. Add auto-instrumentation](#auto-instrum)
* [H. Custom trace instrumentation: Create a custom span](#cust-span)
* [I. Custom trace instrumentation: Create span attribute constants](#attrib-constants)
* [J. Custom trace instrumentation: Record an exception](#record-exception)
* [K. Custom metric instrumentation: Add a custom metric counter](#metrics-cust)
* [L. Custom log instrumentation](#cust-log)
* [M. Exercise the app to generate some traffic](#exercise-app)

<Callout variant="tip">
  While you can manually configure the SDK, we will show you how to configure the SDK using the [autoconfigure option](https://github.com/open-telemetry/opentelemetry-python-contrib/tree/main/instrumentation), which simplifies the the process by using environment variables and system properties.
</Callout>

### A. Download the demo application [#download]

Run the following to download our demo app:

```
git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
```

### B. Install required libraries [#libraries]

To add required libraries:

1. Go to the application directory for the uninstrumented app as the starting point for this tutorial.  By the end of this tutorial, the code should look like the one in the `instrumented` directory.
    ```
    cd newrelic-opentelemetry-examples/getting-started-guides/python/uninstrumented
    ```
2. Install the OpenTelemetry Python API and SDK packages:
    ```
    pip install opentelemetry-api
    pip install opentelemetry-sdk
    ```



Go to our [environment variables reference section](#ref-env-vars) below to see which variables you need to export and then return to these steps.
3. In the same `getting-started-guides/python/uninstrumented/` create a virtual environment, install the required libraries, and run the app:
    | Windows (PowerShell)              | Linux/MacOS (bash)              |
    | :-------------------------------- | :------------------------------ |
    | `pip install virtualenv`          | `getting-started-python`        |
    | `python -m venv venv`             | `otlp`                          |
    | `.\venv\Scripts\Activate.ps1`     | `https://otlp.nr-data.net:4317` |
    | `pip install -r requirements.txt` | `api-key=NEW_RELIC_LICENSE_KEY` |

    <Callout variant="tip">
      Instead of installing PyPI packages from the `requirements.txt` file, you can do this manually:
      ```
      pip install flask
      pip install opentelemetry-instrumentation-logging
      pip install opentelemetry-instrumentation-flask
      pip install opentelemetry-exporter-otlp
      pip install opentelemetry-distro
      ```
    </Callout>

### C. Configure the SDK [#config-sdk]

In `app.py` add the following in a new line after `app = Flask(__name__)`, and change attributes (environment, tags) as needed.

```python
##########################
# OpenTelemetry Settings #
##########################
from opentelemetry.sdk.resources import Resource
import uuid

OTEL_RESOURCE_ATTRIBUTES = {
    "service.name": "getting-started-python",
    "service.instance.id": str(uuid.uuid1()),
    "environment": "local",
    "tags.team": "newrelic"
}
```
In the same `getting-started-guides/python/instrumented/` directory, create and activate a virtual environment, install the required libraries, and run the app:
      * macOS:
        ```
        python3 -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
        python app.py
        ```
        
      * PowerShell:
        ```
        python -m venv venv
        .\venv\Scripts\Activate.ps1
        pip install -r requirements.txt
        python3 app.py
        ```


### D. Add instrumentation libraries: traces [#library-traces]

In `app.py` add the following after the OpenTelemetry Settings above:

```python
##########
# Traces #
##########
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter

# Initialize tracing and an exporter that can send data to an OTLP endpoint
# SELECT * FROM Span WHERE instrumentation.provider='opentelemetry'
trace.set_tracer_provider(TracerProvider(resource=Resource.create(OTEL_RESOURCE_ATTRIBUTES)))
trace.get_tracer_provider().add_span_processor(BatchSpanProcessor(OTLPSpanExporter()))
```

### E. Add instrumentation libraries: metrics [#library-metrics]

In `app.py` add the following after the OpenTelemetry above, or after the Traces section above:

```python
###########
# Metrics #
###########
from opentelemetry import metrics
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import OTLPMetricExporter

# Initialize metering and an exporter that can send data to an OTLP endpoint
# SELECT count(`http.server.active_requests`) FROM Metric FACET `service.name` TIMESERIES
metrics.set_meter_provider(MeterProvider(resource=Resource.create(OTEL_RESOURCE_ATTRIBUTES), metric_readers=[PeriodicExportingMetricReader(OTLPMetricExporter())]))
metrics.get_meter_provider()
```

### F. Add instrumentation libraries: logs [#library-logs]

In `app.py` add the following:

1. Import the logging module and set the `basicConfig` logging level to DEBUG:
  ```
    from flask import Flask, jsonify

    import logging
    logging.basicConfig(level=logging.DEBUG)

    app = Flask(__name__)
  ```
2. Then, add the following section after the Metrics section:
    ```python
    ########
    # Logs # - OpenTelemetry Logs are still in the experimental state
    ########
    from opentelemetry import _logs
    from opentelemetry.sdk._logs import LoggerProvider, LoggingHandler
    from opentelemetry.sdk._logs.export import BatchLogRecordProcessor
    from opentelemetry.exporter.otlp.proto.grpc._log_exporter import OTLPLogExporter

    # Initialize logging and an exporter that can send data to an OTLP endpoint by attaching OTLP handler to root logger
    # SELECT * FROM Log WHERE instrumentation.provider='opentelemetry'
    _logs.set_logger_provider(LoggerProvider(resource=Resource.create(OTEL_RESOURCE_ATTRIBUTES)))
    logging.getLogger().addHandler(LoggingHandler(logger_provider=_logs.get_logger_provider().add_log_record_processor(BatchLogRecordProcessor(OTLPLogExporter()))))
    ```

### G. Add auto-instrumentation [#auto-instrum]

In `app.py` add the following after the OpenTelemetry Settings, or after the Traces or Metrics, or Logs section.  This helps with linking spans for Distributed Tracing and Logs-in-Context.:

```python
########################
# Auto-Instrumentation #
########################
from opentelemetry.instrumentation.flask import FlaskInstrumentor
from opentelemetry.instrumentation.logging import LoggingInstrumentor

# No OTEL SpanID/TraceID for spans/logs if you leave this out
FlaskInstrumentor().instrument_app(app)
LoggingInstrumentor().instrument()
```

### H. Custom trace instrumentation: Create a custom span [#custom-span]

In `app.py` add the highlighted lines. In this case, add this line right before your function definition, after the `@app.route` line but before the `def fibonacci(x):` line:
`@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)`:

```python
@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
```
Here is the larger snippet:

```python lineHighlight=2
@app.route("/fibonacci/<int:x>", strict_slashes=False)
@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
def fibonacci(x):
   
    try:
        assert 1 <= x <= 90
        array = [0, 1]
        for n in range(2, x + 1):
            array.append(array[n - 1] + array[n - 2])

        return jsonify(fibonacci_index=x, fibonacci_number=array[x])

    except (ValueError, AssertionError):
        raise ValueError("x must be 1 <= x <= 90.")

app.run(host='0.0.0.0', port=8080)
```

### I. Custom trace instrumentation: Create span attribute constants [#attrib-constants]

In `app.py` add the following:

1. Create an attribute named `fibonacci.n` with the input value `x`.
    ```python
    trace.get_current_span().set_attribute("fibonacci.n", x)
    ```
2. Add another line just before the return statement to add an attribute called `fibonacci.result` with the evaluated result `array[x]`:
    ```python
    trace.get_current_span().set_attribute("fibonacci.result", array[x])
    ```

    The updated code should now look like this:
    ```python lineHighlight=4,12
    @app.route("/fibonacci/<int:x>", strict_slashes=False)
    @trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
    def fibonacci(x):
        trace.get_current_span().set_attribute("fibonacci.n", x)
        
        try:
            assert 1 <= x <= 90
            array = [0, 1]
            for n in range(2, x + 1):
                array.append(array[n - 1] + array[n - 2])

            trace.get_current_span().set_attribute("fibonacci.result", array[x])
            return jsonify(fibonacci_index=x, fibonacci_number=array[x])

        except (ValueError, AssertionError):
            raise ValueError("x must be 1 <= x <= 90.")

    app.run(host='0.0.0.0', port=8080)
    ```

### J. Custom trace instrumentation: Record an exception [#span-exception]

In `app.py` add the highlighted line.  In this case, when an exception occurs, we set the attribute `otel.status_code = ERROR`. To do this, we also need to import the `Status` and `StatusCode` modules from the `opentelemetry.trace.status package`.

```python lineHighlight=2,20
# Everything Else
# !!!MOVE TO TRACES SECTION!!! 
from opentelemetry.trace.status import Status, StatusCode

# The rest of the Flask application
@app.route("/fibonacci/<int:x>", strict_slashes=False)
@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
def fibonacci(x):
    trace.get_current_span().set_attribute("oteldemo.n", x)
    
    try:
        assert 1 <= x <= 90
        array = [0, 1]
        for n in range(2, x + 1):
            array.append(array[n - 1] + array[n - 2])

        trace.get_current_span().set_attribute("oteldemo.result", array[x])
        return jsonify(fibonacci_index=x, fibonacci_number=array[x])

    except (ValueError, AssertionError):
        trace.get_current_span().set_status(Status(StatusCode.ERROR, "Number outside of accepted range."))
        raise ValueError("x must be 1 <= x <= 90.")

app.run(host='0.0.0.0', port=8080)
```


### K. Custom metric instrumentation: Add a custom metric counter [#metrics-cust]

In `app.py` add the highlighted line.  This creates a counter to show how many times this function runs successfully and how many times it fails to run.

```python lineHighlight=3,18,23
# Everything Else
from opentelemetry.trace.status import Status, StatusCode
fib_counter = metrics.get_meter("opentelemetry.instrumentation.custom").create_counter("fibonacci.invocations", unit="1", description="Counts the number of times this function runs")

# The rest of the Flask application
@app.route("/fibonacci/<int:x>", strict_slashes=False)
@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
def fibonacci(x):
    trace.get_current_span().set_attribute("fibonacci.n", x)
    
    try:
        assert 1 <= x <= 90
        array = [0, 1]
        for n in range(2, x + 1):
            array.append(array[n - 1] + array[n - 2])

        trace.get_current_span().set_attribute("fibonacci.result", array[x])
        fib_counter.add(1, {"fibonacci.valid.n": "true"})
        return jsonify(fibonacci_index=x, fibonacci_number=array[x])

    except (ValueError, AssertionError):
        trace.get_current_span().set_status(Status(StatusCode.ERROR, "Number outside of accepted range."))
        fib_counter.add(1, {"fibonacci.valid.n": "false"})
        raise ValueError("x must be 1 <= x <= 90.")

app.run(host='0.0.0.0', port=8080)
```

### L. Custom log instrumentation [#cust-log]

Edit `app.py` to add the following.  In this case, we add a custom log for INFO so we know what the input and output values are.  Also, we add a custom log for ERROR when the input value is outside of the expected range.

```python lineHighlight=19,25,
# Everything Else
from opentelemetry.trace.status import Status, StatusCode
fib_counter = metrics.get_meter("opentelemetry.instrumentation.custom").create_counter("work.counter", unit="1", description="Counts the number of times this function runs")

# The rest of the Flask application
@app.route("/fibonacci/<int:x>", strict_slashes=False)
@trace.get_tracer("opentelemetry.instrumentation.custom").start_as_current_span("fibonacci", kind=trace.SpanKind.SERVER)
def fibonacci(x):
    trace.get_current_span().set_attribute("fibonacci.n", x)
    
    try:
        assert 1 <= x <= 90
        array = [0, 1]
        for n in range(2, x + 1):
            array.append(array[n - 1] + array[n - 2])

        trace.get_current_span().set_attribute("fibonacci.result", array[x])
        fib_counter.add(1, {"fibonacci.valid.n": "true"})
        logging.info("Compute fibonacci(" + str(x) + ") = " + str(array[x]))
        return jsonify(fibonacci_index=x, fibonacci_number=array[x])

    except (ValueError, AssertionError):
        trace.get_current_span().set_status(Status(StatusCode.ERROR, "Number outside of accepted range."))
        fib_counter.add(1, {"fibonacci.valid.n": "false"})
        logging.error("Failed to compute fibonacci(" + str(x) + ")")
        raise ValueError("x must be 1 <= x <= 90.")

app.run(host='0.0.0.0', port=8080)
```

### M. Exercise the app to generate some traffic [#exercise-app]

You're ready to send some data to New Relic!

1. Go to the directory `getting-started-guides/python/Instrumented` directory, and run the application:
    * PowerShell:
      ```
      python app.py
      ```
    * Linux/Mac:
      ```
      python3 app.py
      ```
2. Generate traffic to the application by opening a new terminal in the getting-started-guides/python/ directory and running the load generator:
    * PowerShell:
      ```
      .\load-generator.ps1
      ```
    * Linux/Mac:
      ```
      ./load-generator.sh
      ```

    <Callout variant="tip">
      Alternatively, you can reach the endpoint in the browser at this URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Replace `INSERT_A_VALUE` with a value from 1 to 90. To generate an error, insert an integer outside the valid range.
    </Callout>

3. Now that you've sent some data to New Relic, see our [instructions on viewing the data in the UI](#view-data).

## View your demo data in New Relic [#view-data]

No matter which tutorial you completed, you can follow the tips below for finding your data in the New Relic UI.

1. Go to **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > APM & services**.
2. Click your new entity (service) called `getting-started-python` (or whatever name you provided).
3. Check out the details in the sections for each data type.

<Callout variant="tip">
  If you are using Microsoft Windows and do not see data in your New Relic account, check that you have allowed traffic through the firewall. 
</Callout>

### Traces [#traces]

Once you've reached the `getting-started-python` entity in New Relic:


1. In the left pane's **Monitor** section, click **Distributed tracing**, and then click the **Fibonacci** trace group.
    <img
      title="Screenshot showing how to find your trace group"
      alt="Screenshot showing how to find your trace group"
      src={opentelemetryPythonFindTraceGroup}
    />
2. From there, find a trace with an error and click to open it:
    <img
      alt="Screenshot showing an error in distributed tracing"
      title="Screenshot showing an error in distributed tracing"
      src={opentelemetryPythonDistributedTracingError}
    />
3. Once you have the trace open, click `Show in-process spans`, and then click on the resulting span, which will open up a details panel to the right. To see the exception you recorded when a user input is invalid, click on `View span events`:
    <img
      title="Screenshot of in-process spans"
      alt="Screenshot of in-process spans"
      src={opentelemetryPythonInProcessSpans}
    />

If you completed the manual instrumentation tutorial, here's how the exception you recorded as a span will look in New Relic:

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryPythonExceptiononSpanEvent}
/>

To view additional details that you set, such as the span attribute, span name, and status code, click on the **Attributes** tab. This pane is also where you can view additional metadata that is automatically collected by the instrumentation libraries you used in this guide, as well as metadata that is attached by New Relic:

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryPytyhonAttributesTab}
/>

For more details about viewing your data, see [OpenTelemetry in the New Relic UI](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)


### Metrics [#metrics]

Once you've reached the `getting-started-python` entity in New Relic, you can see a list of all collected metrics, such as runtime metrics (JVMs) and your custom counter attributes.

#### Metrics explorer [#metrics-explorer]

This is a tool that allows you to see a list of your metrics.

1. In the left pane, select **Data > Metrics explorer**, and then select `fibonacci.invocations`.

    <img
      title="Screenshot showing metrics explorer"
      alt="Screenshot showing metrics explorer"
      src={opentelemetryPythonMetricsExplorerMain}
    />
2. Under **Dimensions**, view the attributes you collected along with your custom metric, and then click on **fibonacci.valid.n**.

    <img
      title="Screenshot showing the total number of invocations of fibonacci function"
      alt="Screenshot showing the total number of invocations of fibonacci function"
      src={opentelemetryPythonMetricsExplorerDimensions}
    />

Learn more in our documentation about the [metrics explorer view](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-metrics-explorer-page).

### Logs [#logs]

Here is where to access your logs:

<img
  title="Screenshot showing the main logs page"
  alt="Screenshot showing the main logs page"
  src={opentelemetryPythonMainLogsPage}
/>

You will also see logs in your terminal:

<img
  title="Screenshot showing logs in a terminal"
  alt="Screenshot showing logs in a terminal"
  src={opentelemetryPythonLogsinTerminal}
/>

Back in your logs view, select a log, and you will see a pane open up with the log message and additional attributes that were collected, such as the associated span and trace ids, as well as metadata injected by New Relic:

<img
  title="Screenshot showing log details with trace"
  alt="Screenshot showing log details with trace"
  src={opentelemetryPythonLogDetailsWithTrace}
/>

You can navigate to the correlated distributed trace by clicking this little blue icon:

<img
  title="Screenshot showing how to find correlated trace"
  alt="Screenshot showing how to find correlated trace"
  src={opentelemetryPythonTraceRelatedtoLog}
/>

This will open a pane that displays the correlated trace, where you can view more details about the trace. For more about this page, see [OpenTelemetry in the UI: Distributed tracing page](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page/) and [Understand and use the distributed tracing UI](/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/):

<img
  title="Screenshot showing the trace waterfall from the logs section"
  alt="Screenshot showing the trace waterfall from the logs section"
  src={opentelemetryPythonTraceWaterfallFromLog}
/>

You can also find the correlated log from the distributed traces view. When you select a trace that has a corresponding log, you will see that indicated as a tab, and you can view the log directly from the trace without having to switch views:

<img
  title="Screenshot showing how to see log details from a trace span"
  alt="Screenshot showing how to see log details from a trace span"
  src={opentelemetryPythonLogCapturedinTraceSpan}
/>

Learn more about the logs view [here](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-logs-page).

## Reference: Environment variables [#ref-env-vars]

This is a list of the environment variables you should export if you're doing tutorial 2 or 3. After you finish exporting the variables, return to the tutorials using the links that follow the variable list:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="env-vars-table"
    title="Click here to open the list of environment variables"
  >
    <table>
      <tbody>
        <tr>
          <td>
            OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY

            * Headers: This determines which New Relic account your data will be sent to. Replace `YOUR_LICENSE_KEY` with your <InlinePopover type="licenseKey" />.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net:4317 (For the US)

            * This is the endpoint your application telemetry will be exported to. Export data to New Relic's OTLP endpoint. If you're in the EU, use this endpoint: OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net:4317
          </td>
        </tr>
        <tr>
          <td>
            OTEL_SERVICE_NAME=getting-started-python

            * This is the name that associates your application telemetry with an entity in New Relic. In this tutorial we're calling it `getting-started-python`, but you could call it anything you want.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE

            * Replace `INSERT_YOUR_OWN_ID_HERE` with a unique instance id. For example, you could use `1234`. For more details, see OpenTelemetry's [Resource Semantic Conventions](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/README.md#service).
          </td>
        </tr>
        <tr>
          <td>
            OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095

            * Setting a limit on the maximum attribute value length will prevent span data from getting dropped if it exceeds the [New Relic limit](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA

            * New Relic supports metrics in delta temporality instead of the default of cumulative.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=EXPONENTIAL_BUCKET_HISTOGRAM

            * (Recommended) Histogram aggregation: Use exponential histogram instead of default explicit bucket histogram for better data compression.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_LOGS_EXPORTER=otlp

            * Enable log export over OTLP. Log export is disabled by default.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPORTER_OTLP_COMPRESSION=gzip

            * (Recommended) Setting gzip compression allows you to maximize the amount of data you can send per request. Our maximum allowed payload size is 1MB (10^6 bytes). Gzip compression has good performance and lowers data egress.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true

            * (Recommended) Enable experimental export retry to help cope with the unreliability of the internet.
          </td>
        </tr>
        <tr>
          <td>
            OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line

            * (Recommended) This disables the `process.command_line` resource attribute which often exceeds the New Relic maximum attribute length limit and may contain sensitive information.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

After you've created the environment variables listed in the collapser above, return to the tutorial and complete the setup:
* [Tutorial 2: Monitor the demo app with the OpenTelemetry Python agent](#python-agent)
* [Tutorial 3: Set up the demo app manually](#manual-instrum)


## What's next? [#what-next]

Now that you've experimented with OpenTelemetry instrumentation and SDK configuration, you can apply what you've learned to set up your own app or service with OpenTelemetry and New Relic. For more, see [Set up your own app or service with OpenTelemetry](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/get-started/opentelemetry-set-up-your-app).