---
title: Create meaningful service levels for gameday
metaDescription: "Learn to find important business capabilities, define your baselines, and set up meaningful service levels for peak demand."
---

import userJourneyAPossibleUserJourney from 'images/user-journey_screenshot-full_A-possible-user-journey.gif'

import latencyBaselineLatencyBaselineQuery from 'images/latency-baseline_screenshot-full_Latency-baseline-query.webp'

import successBaselineSuccessBaseline from 'images/Success-baseline_screenshot-full_success-baseline.webp'

import serviceLevelsintheUIServiceLevelsintheUI from 'images/Service-levels-in-the-UI_screenshot-full_Service-levels-in-the-UI.webp'

import serviceLevelsUI from 'images/Service-levels-UI_screenshot-crop.webp'

Preparing for your company's big event can expose weak points in your observability practices. As your architecture gets more complex, honing in on the business critical apps and services can be a challenge. You can't prioritize everything all at once, but you want gameday to be a success. How can New Relic help you stay in the loop when it matters?

Our biggest recommendation for any team going into an event is to set up service levels. With service levels, tech speak gets translated into business speak. While a team is thinking in terms of entities, service level asks that you break down those entities into their requisite parts, like transactions.

This tutorial explains why service levels are important, how to determine which capabilities need service levels, and how to create them for a gameday.

## Identify your priorities [#understand]

If you usually think in terms hosts, apps, and services, finding your priorities can be tricky, and the whole point of capacity planning is prioritizing the right things. We recommend evaluating how customers interact with your app, then identifying capabilities that power those customer touchpoints. Follow this example user journey:

<img
    title="This user journey has a few points to add a service level to"
    alt="User journey"
    src={userJourneyAPossibleUserJourney}
/>

<figcaption>
    An example user journey through an eCommerce site.
</figcaption>

How many capabilities does this user touch during their journey? Each action corresponds to a potential service level. To help identify your own app capabilities, we have some preliminary questions you might ask yourself about your architecture:

* What journeys do your customers most frequently go through?
* Of those, journeys involve purchase transactions? 
* What key entities support business?
* Do any of the transactions, services, or customer journeys have any gaps? Do they need to be monitored? 

By answering these questions, you can create a business narrative informed by your architecture needs. Data collected about an API call, click action, or transaction can be transformed into an indicator for business health.

## Query New Relic to find popular customer touchpoints  [#query]

Having an idea of what your customers use on day-to-day is different from identifying the specific capability in your architecture. You can use New Relic to query for these touchpoints. For example, take how you'd find your important transactions: 

<Steps>
    <Step>
        
### Find popular transactions  
        
Go to **[one.newrelic.com > Query Your Data](https://one.newrelic.com/data-exploration/query-builder)**, then input the following query:

<SideBySide>
    <Side>
    
    ```sql
    FROM Transaction SELECT count(*) FACET request.uri SINCE 1 week AGO
    ```    
    </Side>
    <Side>
SCREENSHOT
    </Side>
</SideBySide>

This query pulls all data about your app's transactions, then filters to only include transactions where a request is made to your app. From the table of `request.uri`s, we see that `/js/controllers/` is a popular `request.uri`. We'll work with this one. 

    </Step>
    <Step>
    
    ### Update query to find latency baseline and Success baseline

    Focusing on `/js/controllers/`, update the above query to:

    * Remove the `FACET` and focus the query on that particular URI
    * Replace the total `count(*)` with `percentile(duration, 95)`

<SideBySide>
    <Side>

        ```sql
        FROM Transaction SELECT percentile(duration, 95) AS 'Latency Baselines', percentage(count(*), WHERE error is false) AS 'Success Baseline' SINCE 1 WEEK AGO WHERE request.URI LIKE '/js/services/%'
        ```
    </Side>
    <Side>

SCREENSHOT

    </Side>
</SideBySide>

This query tells us that the transaction typically responds at 42(ms) and has a 99.27% success rate. This is our latency baseline. 

</Step>

<Step>
### Find the source app


<SideBySide>
    <Side>
    ```sql
    FROM Transaction SELECT percentile(duration, 95) AS 'Latency Baselines', percentage(count(*), WHERE error is false) AS 'Success Baseline' SINCE 1 WEEK AGO WHERE request.URI LIKE '/js/controllers/ FACET appName
    ```
    </Side>
    <Side>
SCREENSHOT
    </Side>
</SideBySide>

</Step>
</Steps>

Depending on your system architecture, you can use this query to locate similar capabilities such as: 

* Logging in
* Searching for an item
* Adding an item to a cart
* Making a payment  
* Order processing

These customer behaviors correlate to capabilities behind a web app, and it's those capabilities you want to baseline. When you're choosing the focus for a game day, it's important correlate common customer needs to a capability in your architecture. 

Understanding baseline behavior lets you determine if a change in behavior is something to resolve. To use our coffee example, noticing a change in flavor indicates that something might be wrong with your machine. Maybe it needs to be cleaned, or maybe the heating element went out. Regardless, you need to find the root cause of the anomalous behavior.  

## Create baseline-informed service levels [#service]

After you've found what to prioritize, your next step is figure out how your app behaves on an ordinary day. Your app's ordinary behavior is a baseline, which is a kind of expectation. Think of your cup of morning coffee: you have an expectation of what that coffee tastes like, so any difference in taste can indicate a problem with your machine. 

If you only just started reporting data to New Relic, you can create your first set of service levels by copy/pasting some queries from our [introductory service level tutorial](/docs/journey-performance/slo-tutorial/). If you've been reporting data to New Relic, you have what you need to get an initial baseline metric. 

There are three parts to preparing for a peak demand day with service levels:

1. Finding your baseline with NRQL
2. Creating your service level with our UI
3. Attaching an alert policy to the service level

To identify your baseline, go to **[one.newrelic.com > Query Your Data](https://one.newrelic.com/data-exploration/query-builder)**. 

Let's assume that when evaluating our entities, we discovered a gap in coverage on our order processing service. We can take the following query and create a latency baseline. (If you're following along with your own app, be sure to change `appName='Order-Processing'`.)

<Steps>
    <Step>


<SideBySide>
    <Side>
    But let's say you want to supplement this baseline with an error-free baseline. You can edit the query to look like this:

```sql
FROM Transaction SELECT percentage(count(*), WHERE error is false) AS 'Success Baseline SLI' SINCE 1 WEEK AGO WHERE appName='Order-Processing'
```
    </Side>
    <Side>
<img
    title="Success baseline query"
    alt=""
    src={successBaselineSuccessBaseline}
/>
    </Side>
</SideBySide>
    </Step>
</Steps>

## Find acceptable thresholds for your service levels [#thresholds]

Now that you have some baselines, you can create a meaningful service level. From the **Query Your Data** page, head back to **[one.newrelic.com](https://one.newrelic.com) > APM & Services**, then click **Service levels** located under **Reports**.

When you add a new service level, New Relic will auto-populate a baseline for your entire app. This automatic baseline averages all data from every transaction from a particular entity. While useful in some cases, we're wanting to monitor specific capabilities that could have catastrophic consequences on a peak demand day. 

With the baseline we pulled from the previous section, we can edit the `WHERE` box. Add the following string to the end of the populated query so the line reads:

```sql
entityGUID = 'YOUR_GUID' AND (transactionType = 'Web') AND request.uri LIKE `Order-processing`
```

New Relic will update the rest of the form, so your last step is naming your new SLI. 

<SideBySide>
    <Side>
        <img
    title="View your service levels"
    alt=""
    src={serviceLevelsintheUIServiceLevelsintheUI}
/>
    </Side>
    <Side>
        <img
        title="Service levels summary page"
        src={serviceLevelsUI}
        />
    </Side>
</SideBySide>