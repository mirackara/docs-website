---
title: "Create meaningful service levels for gameday"
metaDescription: "Elephant."
---

import userJourneyAPossibleUserJourney from 'images/user-journey_screenshot-full_A-possible-user-journey.gif'

import latencyBaselineLatencyBaselineQuery from 'images/latency-baseline_screenshot-full_Latency-baseline-query.webp'

import successBaselineSuccessBaseline from 'images/Success-baseline_screenshot-full_success-baseline.webp'

import serviceLevelsintheUIServiceLevelsintheUI from 'images/Service-levels-in-the-UI_screenshot-full_Service-levels-in-the-UI.webp'

import serviceLevelsUI from 'images/Service-levels-UI_screenshot-crop.webp'

Preparing for your company's big event can expose weak points in your observability practices. As your architecture gets more and more complex, honing in on the business critical apps and services can be a challenge. You can't prioritize everything all at once, but you want gameday to be a success. How can New Relic help you stay in the loop when it matters?

Our biggest recommendation for any team going into an event is to set up service levels. With service levels, tech speak gets translated into business speak. While a team is thinking in terms of entities, service level asks that you break down those entities into their requisite parts, like transactions.

This tutorial explains why service levels are important, how to determine which capabilities need service levels, and how to create them for a gameday.

## Why service levels? [#why]

If you usually think in terms of entities, identifying what transactions to prioritize can be tricky, and the whole point of capacity planning is prioritizing the right things. Even with existing service levels, it's good practice to reasses their effectivity and create new ones to fit new business needs. Take this short user journey: 

<img
    title="This user journey has a few points to add a service level to"
    alt="User journey"
    src={userJourneyAPossibleUserJourney}
/>

<figcaption>
    An example user journey through an eCommerce site.
</figcaption>

How many capabilities does this user touch during their journey? Each action translates into a service level that you can monitor. Before getting started with creating service levels, we have some preliminary questions you might ask yourself about your architecture:

* What journeys do your customers most frequently go through?
* Of those, journeys involve purchase transactions? 
* What key entities support business?
* Do any of the transactions, services, or customer journeys have any gaps? Do they need to be monitored? 

By compiling this list, you can create a business narrative around technical concepts. Out of the box data like an API call, click action, or transaction can be transformed into an indicator for business health. Can you identify what 

Beyond prioritization, knowing what parts of your architecture correspond to important business metrics (or KPIs) is another part of capacity planning. It enables clear communication between teams with different focuses on the same system. 

## Identify your performance needs [#boundary]

You can think of a baseline as ordinary behavior. Take your cup of morning coffee. You have an expectation of what that coffee will taste like, even if you don't understand how acidity or body shapes flavor. When your coffee machine breaks, it alters the flavor. The difference between your baseline expectation and the new (perhaps watery, or burnt) taste is what makes up an incident. Without your baseline, however, you might not notice any difference in flavor. 

In any case, when you're preparing for a peak demand period, you want to establish your baselines so you know what anomalous looks like. Let's say we've gone through our preliminary questions, and we've identified the following activities as stand-ins for our KPIs:

* Logging in
* Searching for an item
* Adding an item to a cart
* Making a payment  
* Order processing

These customer behaviors correlate to capabilities behind a web app, and it's those capabilities you want to baseline. When you're choosing the focus for a game day, it's important correlate common customer needs to a capability in your architecture. These capabilities should *always* meet demand because they drive business. 

Understanding baseline behavior lets you determine if a change in behavior is something to resolve. To use our coffee example, noticing a change in flavor indicates that something might be wrong with your machine. Maybe it needs to be cleaned, or maybe the heating element went out. Regardless, you need to find the root cause of the anomalous behavior.  

## Baseline, then make your service levels [#baseline]

If you only just started reporting data to New Relic, you can create your first set of service levels by copy/pasting some queries from our [introductory service level tutorial](/docs/journey-performance/slo-tutorial/). If you've been reporting data to New Relic, you have what you need to get an initial baseline metric. 

There are three parts to preparing for a peak demand day with service levels:

1. Finding your baseline with NRQL
2. Creating your service level with our UI
3. Attaching an alert policy to the service level

To identify your baseline, go to **[one.newrelic.com > Query Your Data](https://one.newrelic.com/data-exploration/query-builder)**. 

Let's assume that when evaluating our entities, we discovered a gap in coverage on our order processing service. We can take the following query and create a latency baseline. (If you're following along with your own app, be sure to change `appName='Order-Processing'`.)

<SideBySide>
    <Side>
        ```sql
FROM Transaction SELECT percentile(duration, 95) AS 'Latency Baseline SLI' WHERE appName='Order-Processing' SINCE 1 WEEK AGO
```
This query shows that 95% of requests to `Order-Processing` received a response in less than 1.844(ms). Your latency baseline is 0.6. 

    </Side>
    <Side>
        <img
    title="Query to find your latency baseline"
    alt=""
    src={latencyBaselineLatencyBaselineQuery}
/>

    </Side>
</SideBySide>

<SideBySide>
    <Side>
    But let's say you want to supplement this baseline with an error-free baseline. You can edit the query to look like this:

```sql
FROM Transaction SELECT percentage(count(*), WHERE error is false) AS 'Success Baseline SLI' SINCE 1 WEEK AGO WHERE appName='Order-Processing'
```
    </Side>
    <Side>
<img
    title="Success baseline query"
    alt=""
    src={successBaselineSuccessBaseline}
/>
    </Side>
</SideBySide>

## Find acceptable thresholds for your service levels [#thresholds]

Now that you have some baselines, you can create a meaningful service level. From the **Query Your Data** page, head back to **[one.newrelic.com](https://one.newrelic.com) > APM & Services**, then click **Service levels** located under **Reports**.

When you add a new service level, New Relic will auto-populate a baseline for your entire app. This automatic baseline averages all data from every transaction from a particular entity. While useful in some cases, we're wanting to monitor specific capabilities that could have catastrophic consequences on a peak demand day. 

With the baseline we pulled from the previous section, we can edit the `WHERE` box. Add the following string to the end of the populated query so the line reads:

```sql
entityGUID = 'YOUR_GUID' AND (transactionType = 'Web') AND request.uri LIKE `Order-processing`
```

New Relic will update the rest of the form, so your last step is naming your new SLI. 

<SideBySide>
    <Side>
        <img
    title="View your service levels"
    alt=""
    src={serviceLevelsintheUIServiceLevelsintheUI}
/>
    </Side>
    <Side>
        <img
        title="Service levels summary page"
        src={serviceLevelsUI}
        />
    </Side>
</SideBySide>