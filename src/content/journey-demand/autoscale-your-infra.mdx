---
title: Autoscale your infrastructure with Kubernetes
metaDescription: "Elephant."
---

Scaling your infrastructure for a big event can be tricky. You have to balance cost considerations against what's functionally great for your system, all while speculating on what demand *could* look like in a future time. As we've seen, preparing for peak demand requires plenty of planning: you have to establish your baselines, assess your service level agreements, and ensure all your teams are aligned on the day of. With infrastructure planning, you want to know in advance that you have the resources to meet demand. One solution to this problem is Kubernetes autoscaling.

New Relic can trigger pod autoscaling in your Kubernetes cluster by reporting metrics about CPU and memory. Autoscaling works in both directions. If your system experiences an increase in requests, then New Relic can report that to Kubernetes, triggering more pod allocation (or less, as load returns to ordinary levels). Autoscaling sidesteps the issue of anticipating demand and reacting to resource needs as a peak demand period approaches.

This tutorial walks you through setting up an example environment for Horizontal Pod Autoscaling (HPA). If you're in the planning periods of capacity planning, then this tutorial is right for you. 

## Prerequisites [#req]

The tutorial assumes that you're using Kubernetes clusters.  To set up HPA, you'll need:

* Kubernetes 1.16 or higher
* Your New Relic user API key 
* No other External Metrics Adapter installed in the cluster

## Forward metrics to Kubernetes [#k8s]

<Steps>
    <Step>
        ### Clone our New Relic Pixie lab repo

        Clone the following repo from Github:

        ```git 
        $ git clone https://github.com/newrelic-experimental/pixie-lab-materials 
        $ ​​cd pixie-lab-materials/main 
        $ ./setup.sh
        ```
    The `setup.sh` script will:

    * Spin up a new minikube cluster using the Pixie-supported hyperkit driver * Configure your network memory and CPU for optimal performance with Pixie * Create all the pods and services that make up the demo application

In a new terminal window, open a minikube tunnel:

`$ minikube tunnel -p minikube-pixie-lab`

Your two terminal windows should include: 

* One that contains your tunnel. This needs to remain open to access your demo application.
* One for running the other commands in this tutorial.

    </Step>
    <Step>
        ### Install the Kubernetes integration with Pixie

        Follow our [guided install](https://one.newrelic.com/nr1-core?account=2498654&state=d1aae74b-0ad6-b0f3-093d-cc89ecf89234) to install the New Relic Kubernetes integration. This establishes a connection between New Relic and Kubernetes. The guided install will prompt some set up details:

        * Enable Pixie by checking **Instant service-level insights**, **full-body requests**, and **application profiles through Pixie**
        * Keep all default checked items

        Once you click continue, New Relic generates a command. Copy and paste that command into your dev environment. 

    </Step>
    <Step>
        ### Install New Relic Metrics Adapter

ASK DANIEL WHAT 'USE' MEANS HERE. ARE THEY C/PING IN HELM CHART? WILL EVERYONE USING K8S KNOW WHAT THIS IS? IF NOT, WHAT DO WE WRITE HERE TO CONTEXTUALIZE?

        Use the `newrelic-k8s-metrics-adapter` Helm chart to run this script:

        ```
        helm upgrade --install newrelic newrelic/nri-bundle \
        --namespace newrelic --create-namespace --reuse-values \
        --set metrics-adapter.enabled=true \
        --set newrelic-k8s-metrics-adapter.personalAPIKey=YOUR_NEW_RELIC_PERSONAL_API_KEY \
        --set newrelic-k8s-metrics-adapter.config.accountID=YOUR_NEW_RELIC_ACCOUNT_ID \
        --set newrelic-k8s-metrics-adapter.config.externalMetrics.manipulate_average_requests.query='FROM Metric SELECT average(http.server.duration) WHERE instrumentation.provider='pixie''
        ```

        Here is additional context on the flags in the previous command:

        * `metrics-adapter.enabled`: Set to true to install the metrics adapter chart
        * `newrelic-k8s-metrics-adapter.personalAPIKey`: Set your New Relic API key.
        * `newrelic-k8s-metrics-adapter.accountID`: The New Relic account ID that will forward metrics.
        * `newrelic-k8s-metrics-adapter.config.externalMetrics.external_metric_name.query`: Adds a new external metric with the following information:
            * `external_metric_name`: The metric name.
            * query: The base NRQL query for the metric.


    </Step>
    <Step>
        ### Confirm your NRQL query is accurate

        Before letting New Relic sends metrics that prompt your cluster to scale test your query. Go to **[one.newrelic.com](https://one.newrelic.com) > Query your Data**, then copy and paste the following NRQL query:

        ```sql
        FROM Metric SELECT average(http.server.duration) WHERE instrumentation.provider='pixie'
        ```

        HOW WILL THEY KNOW IT'S CORRECT? ASK DANIEL 
    </Step>
    <Step>
        ### Configure your autoscaler

        From the `pixie-lab-materials/main/kube` directory, create a new file called `hpa.yml`. The New Relic metrics adapter sends data to the controller manager, which is defined by the HPA definition in this YAML file. 

        ```yml
        kind: HorizontalPodAutoscaler
        apiVersion: autoscaling/v2beta2
        metadata:
            name: manipulate-scaler
        spec:
            scaleTargetRef:
                apiVersion: apps/v1
                kind: Deployment
                name: manipulation-service
            minReplicas: 1
            maxReplicas: 10
            metrics:
                - type: External
                    external:
                        metric:
                            name: manipulate_average_requests
                        target:
                            type: Value
                            value: 100
        ```
Apply the new YAML file by running:

```
$ cd pixie-lab-materials/main/kube
$ ​​kubectl apply -f hpa.yaml
```
    </Step>
</Steps>

## Check your work: Add load to trigger autoscaling [#check]

1. Navigate to your site deployment with `$ kubectl get services`
2. Open the EXTERNAL-IP from your frontend-service in your browser.
3. Install `hey` and Go v1.17 with `$ brew install hey`
4. Send GET requests to the EXTERNAL-IP with `$ hey -n 10 -c 2 -m GET http://<EXTERNAL-IP>
5. Watch your HPA autoscalling with `$ watch kubnectl get hpa` 